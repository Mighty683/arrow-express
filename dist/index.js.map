{"version":3,"file":"index.js","sources":["../lib/application/application.ts","../lib/controller/controller.ts","../lib/route/route.ts","../lib/error/configuration.error.ts","../lib/error/request.error.ts","../lib/express-adapter/adapter.ts"],"sourcesContent":["import { ControllerConfiguration, ControllerHandler } from \"../controller/controller\";\nimport { RouteConfiguration } from \"../types\";\nexport class AppConfigurator {\n  private _prefix = \"\";\n  private readonly _controllers: ControllerConfiguration<any>[] = [];\n  private readonly logRequests: boolean;\n\n  /**\n   * Create AppConfigurator\n   * @param expressApplication - express application\n   * @param logRequests - flag if requests should be logged, true by default\n   */\n  constructor(logRequests = true) {\n    this.logRequests = logRequests;\n  }\n\n  /**\n   * Register prefix for all paths in application\n   * @param prefix - prefix string eg: 'api'\n   */\n  prefix(prefix: string): AppConfigurator {\n    this._prefix = prefix;\n    return this;\n  }\n\n  getPrefix(): string {\n    return this._prefix;\n  }\n\n  /**\n   * Register controller in application.\n   * @param controller - registered controller\n   */\n  registerController(controller: ControllerConfiguration<any, any>): AppConfigurator {\n    this._controllers.push(controller);\n    return this;\n  }\n\n  /**\n   * Register list of controllers in application.\n   * @param controllers - controllers to register\n   */\n  registerControllers(...controllers: ControllerConfiguration<any, any>[]): AppConfigurator {\n    controllers.forEach(controller => this.registerController(controller));\n    return this;\n  }\n\n  getControllers(): ControllerConfiguration<any>[] {\n    return this._controllers;\n  }\n\n  /**\n   * @description\n   * Build routes from registered controllers.\n   * It will create route configuration for each controller and its sub-controllers.\n   * The route configuration will include the path, method, and handler for each route.\n   * The handler will call the controller's handler and then the route's request handler.\n   * If the controller has sub-controllers, it will recursively build routes for them as well.\n   * @returns Array of route configurations built from registered controllers.\n   */\n  buildRoutes(): RouteConfiguration[] {\n    return this._controllers.reduce<RouteConfiguration[]>(\n      (routes, controller) => routes.concat(this.reduceController(controller, this._prefix)),\n      []\n    );\n  }\n\n  private reduceController(\n    controller: ControllerConfiguration<any, any>,\n    path?: string,\n    handler?: ControllerHandler\n  ): RouteConfiguration[] {\n    return controller\n      .getRoutes()\n      .map<RouteConfiguration>(route => {\n        const routeConfiguration: RouteConfiguration = {\n          path: AppConfigurator.getRoutePath(path || \"\", controller.getPrefix(), route.getPath()),\n          method: route.getMethod(),\n          handler: async (res, req, context) => {\n            const currentContext = (await handler?.(res, req, context)) || context;\n            const controllerContext = await controller.getHandler()?.(res, req, currentContext);\n\n            return route.getRequestHandler()?.(res, req, controllerContext || currentContext);\n          },\n        };\n\n        return routeConfiguration;\n      })\n      .concat(\n        controller.getControllers().reduce((subRoutes, subController) => {\n          return subRoutes.concat(\n            this.reduceController(subController, controller.getPrefix(), async (res, req, context) => {\n              const currentContext = (await handler?.(res, req, context)) || context;\n              return controller.getHandler()?.(res, req, currentContext);\n            })\n          );\n        }, [] as RouteConfiguration[])\n      );\n  }\n\n  /**\n   * Get final route path\n   * @param paths - array of paths\n   * @private\n   */\n  private static getRoutePath(...paths: string[]) {\n    return paths.filter(path => !!path).join(`/`);\n  }\n}\n\nexport function Application(): AppConfigurator {\n  return new AppConfigurator();\n}\n","import { RouteConfigurator } from \"../route/route\";\n\nimport { IsUndefinedOrNeverOrUnknown } from \"../utils/types\";\nimport { ArrowExpress } from \"../types\";\n\nexport type ControllerHandler<Context = unknown, RootContext = unknown> = (\n  request: ArrowExpress.InternalRequestType,\n  response: ArrowExpress.InternalResponseType,\n  rootContext?: RootContext\n) => Promise<Context>;\nexport class ControllerConfiguration<C = unknown, R = unknown> {\n  private _prefix = \"\";\n  private _controllers: ControllerConfiguration<any, GetFinalControllerContext<C, R>>[] = [];\n  private _routes: RouteConfigurator<GetFinalControllerContext<C, R>>[] = [];\n  private _handler: ControllerHandler<GetFinalControllerContext<C, R>, R> | undefined;\n\n  /**\n   * Register child controller in controller\n   * @param controller - controller to register\n   */\n  registerController(controller: ControllerConfiguration<any, GetFinalControllerContext<C, R>>): this {\n    this._controllers.push(controller);\n    return this;\n  }\n\n  /**\n   * Register array of controllers in controller\n   * @param controllers - routes used in controller\n   */\n  registerControllers(...controllers: ControllerConfiguration<any, GetFinalControllerContext<C, R>>[]): this {\n    controllers.forEach(this.registerController.bind(this));\n    return this;\n  }\n\n  /**\n   * Register route in controller\n   * @param route - route used in controller\n   */\n  registerRoute(route: RouteConfigurator<GetFinalControllerContext<C, R>, any>): this {\n    this._routes.push(route);\n    return this;\n  }\n\n  /**\n   * Register array of routes in controller\n   * @param routes - routes used in controller\n   */\n  registerRoutes(...routes: RouteConfigurator<GetFinalControllerContext<C, R>, any>[]): this {\n    routes.forEach(this.registerRoute.bind(this));\n    return this;\n  }\n  /**\n   * Register controller prefix which will be used by all routes\n   * @param prefix - eg: 'login'\n   */\n  prefix(prefix: string): this {\n    this._prefix = prefix;\n    return this;\n  }\n\n  /**\n   * Register controller handler which will be used by all routes\n   * @param handler - ControllerHandler function\n   */\n  handler<NewContext>(handler: ControllerHandler<NewContext, R>): ControllerConfiguration<NewContext, R> {\n    this._handler = handler as unknown as ControllerHandler<GetFinalControllerContext<C, R>, R>;\n    return this as unknown as ControllerConfiguration<NewContext, R>;\n  }\n\n  getPrefix(): string {\n    return this._prefix;\n  }\n\n  getRoutes(): RouteConfigurator<GetFinalControllerContext<C, R>>[] {\n    return this._routes;\n  }\n\n  getControllers(): ControllerConfiguration<any, GetFinalControllerContext<C, R>>[] {\n    return this._controllers;\n  }\n\n  getHandler(): ControllerHandler<GetFinalControllerContext<C, R>, R> | undefined {\n    return this._handler;\n  }\n}\n\nexport function Controller<C = unknown, R = unknown>(): ControllerConfiguration<GetFinalControllerContext<C, R>, R> {\n  return new ControllerConfiguration<GetFinalControllerContext<C, R>, R>();\n}\n\ntype GetFinalControllerContext<Context, RootContext> = IsUndefinedOrNeverOrUnknown<Context> extends true\n  ? RootContext\n  : Context;\n","import { ArrowExpress } from \"../types\";\n\nexport type RouteHandler<RootContext = unknown, ResponseObject = unknown> = (\n  request: ArrowExpress.InternalRequestType,\n  response: ArrowExpress.InternalResponseType,\n  context: RootContext\n) => ResponseObject | Promise<ResponseObject>;\nexport type HttpMethod = \"get\" | \"post\" | \"head\" | \"put\" | \"delete\" | \"options\" | \"patch\";\n\nexport class RouteConfigurator<RootContext = unknown, Response = unknown> {\n  private _method!: HttpMethod;\n  private _path!: string;\n  private _handler!: RouteHandler<RootContext, Response>;\n\n  /**\n   * Set method for route\n   * @param method - Method\n   */\n  method(method: HttpMethod): this {\n    this._method = method || \"get\";\n    return this;\n  }\n  /**\n   * Register path of route alongside with prefix it is used to create full path\n   * @param path\n   */\n\n  path(path: string): this {\n    this._path = path;\n    return this;\n  }\n\n  /**\n   * Set request handler, here you can handle request\n   * @param handler - RouteHandler\n   */\n  handler(handler: RouteHandler<RootContext, Response>): this {\n    this._handler = handler;\n    return this;\n  }\n\n  getMethod(): string {\n    return this._method;\n  }\n\n  getPath(): string {\n    return this._path;\n  }\n\n  /**\n   * Get request handler function\n   * @return - function which is called by express application on request\n   */\n  getRequestHandler(): RouteHandler<RootContext, Response> {\n    return this._handler;\n  }\n}\n\nexport function Route<C = unknown, R = unknown>(): RouteConfigurator<C, R> {\n  return new RouteConfigurator<C, R>();\n}\n","/**\n * Error related to arrow-express configuration.\n */\nexport class ConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, ConfigurationError.prototype);\n  }\n}","/**\n * Error type used by arrow-express to handle errors.\n */\nexport class RequestError extends Error {\n    response?: Record<string, unknown>\n    httpCode: number\n\n    /**\n   * RequestError constructor\n   * @param httpCode - HTTP response code used by arrow-express default 500\n   * @param response - response body send on error\n   */\n    constructor(httpCode?: number, response?: Record<string, unknown>) {\n      super('Wrong api response');\n      this.response = response;\n      this.httpCode = httpCode || 500;\n      /**\n       * Workaround for error extending\n       * https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n       */\n      Object.setPrototypeOf(this, RequestError.prototype);\n    }\n}","import type { Express, RequestHandler, Response, Request } from \"express\";\nimport { AppConfigurator } from \"../application/application\";\nimport { ConfigurationError } from \"../error/configuration.error\";\nimport { RouteConfiguration } from \"../types\";\nimport { RequestError } from \"../error/request.error\";\n\nexport class ExpressAdapterConfiguration {\n  private readonly _express: Express;\n  private readonly _appConfigurator: AppConfigurator;\n  private _configured: boolean;\n  constructor(express: Express, appConfigurator: AppConfigurator) {\n    this._configured = false;\n    this._express = express;\n    this._appConfigurator = appConfigurator;\n  }\n\n  private static expressRouteAsString(r: any) {\n    return `${Object.keys(r.route.methods)[0].toUpperCase()}:${r.route?.path}`;\n  }\n\n  private registerRouteInExpress(routeConfiguration: RouteConfiguration) {\n    if (!routeConfiguration.method || !routeConfiguration.handler) {\n      throw new ConfigurationError(\n        `${routeConfiguration.path} route is not properly configured, missing path, method or handler`\n      );\n    }\n    (this._express as any)[routeConfiguration.method](\n      `/${routeConfiguration.path}`,\n      this.createRequestHandler(routeConfiguration)\n    );\n  }\n\n  private getExpressRoutesAsStrings() {\n    console.log(this._express);\n    return this._express.router.stack.filter((r: any) => r.route).map(ExpressAdapterConfiguration.expressRouteAsString);\n  }\n\n  private printExpressConfig() {\n    console.log(\"Routes registered by Express server:\");\n    this.getExpressRoutesAsStrings().forEach((route: string) => console.log(route));\n  }\n\n  private static canSendResponse(res: Response) {\n    return !res.writableEnded;\n  }\n\n  private createRequestHandler(routeConfiguration: RouteConfiguration): RequestHandler {\n    return async (req: Request, res: Response) => {\n      try {\n        let context: unknown;\n\n        const response = await routeConfiguration.handler(req, res, context);\n        if (ExpressAdapterConfiguration.canSendResponse(res)) {\n          if (!res.statusCode) {\n            res.status(200);\n          }\n          res.send(response);\n        }\n      } catch (error) {\n        if (ExpressAdapterConfiguration.canSendResponse(res)) {\n          if (error instanceof RequestError) {\n            res.status(error.httpCode || 500).send(error.response || \"Internal error\");\n          } else {\n            res.status(500).send(\"Internal error\");\n          }\n        }\n      }\n    };\n  }\n\n  /**\n   * Starts application, register controllers routes in express app\n   * and connect to configured port.\n   * @param printConfiguration - print express application routes enabled by default.\n   */\n  configure(printConfiguration = true): void {\n    if (this._configured) {\n      throw new ConfigurationError(\"Cannot configure application multiple times\");\n    } else {\n      this._configured = true;\n    }\n    const routesConfigurations = this._appConfigurator.buildRoutes();\n    routesConfigurations.forEach(routeConfiguration => this.registerRouteInExpress(routeConfiguration));\n    if (printConfiguration) {\n      this.printExpressConfig();\n    }\n  }\n}\n\nexport const ExpressAdapter = (express: Express, appConfigurator: AppConfigurator): ExpressAdapterConfiguration => {\n  return new ExpressAdapterConfiguration(express, appConfigurator);\n};\n"],"names":[],"mappings":"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"}